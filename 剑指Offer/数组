——————————————————————————————————————————————————————————————————————————————————————————————————
【二维数组的查找】
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
class Solution:
    def Find(self, target, array):
    	m, n = len(array), len(array[0])
	i, j = 0, n-1
	while i < m and j >= 0:
		if array[i][j] == target:
			return True
		elif array[i][j] > target:
			j -= 1
		else:
			i += 1
	return False


——————————————————————————————————————————————————————————————————————————————————————————————————
【旋转数组的最小数字】*****
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 
输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
class Solution:
	def minNumberInRotateArray(self, rotateArray):
		m = len(rotateArray)
		if m == 0:
			return 0
		l, r = 0, m-1
		while l < r:
			mid = (r + l) >> 1
			if rotateArray[mid] > rotateArray[r]:
				l = mid + 1
			elif rotateArray[mid] == rotateArray[r]:
				r = r - 1
			else:
				r = mid
		return rotateArray[l]


——————————————————————————————————————————————————————————————————————————————————————————————————
【最小的K个数】
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
class Solution:
	def GetLeastNumbers_Solution(self, tinput, k):
		if len(tinput) == 0 or k > len(tinput) or k<=0:
			return []
		l, r = 0, len(tinput) - 1
		index = self.Partition(tinput, l, r)
		while index != k - 1:
			if index > k-1:
 				r = index - 1
				index = self.Partition(tinput, l, r)
			else:
				l = index + 1
				index = self.Partition(tinput, l, r)
		return sorted(tinput[:k])
	def Partition(self,numbers,l,r):
		x = numbers[r]
		i = l - 1
		for j in range(l,r):
    			if numbers[j] <= x:
				i += 1
				numbers[i], numbers[j] = numbers[j], numbers[i]
		numbers[i+1], numbers[r] = numbers[r], numbers[i+1]
		return i+1


——————————————————————————————————————————————————————————————————————————————————————————————————
【数组中出现次数超过一半的数字】
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。
由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
class Solution:
	def MoreThanHalfNum_Solution(self, numbers):
		if len(numbers) == 0:
			return 0
		l, r = 0, len(numbers)-1
		index = self.partition(numbers, l, r)
		while index != len(numbers)/2:
			if index > len(numbers)/2:
				r = index - 1
				index = self.partition(numbers, l, r)
			else:
				l = index + 1
				index = self.partition(numbers, l, r)
		res = self.check(numbers, numbers[index])
		if res:
			return numbers[index]
		else:
			return 0
	def partition(self, array, l, r):
		x = array[r]
		i = l - 1
		for j in range(l, r):
			if array[j] <= x:
				i += 1
				array[i], array[j] = array[j], array[i]
		array[i+1], array[r] = array[r], array[i+1]
		return i+1
	def check(self, array, x):
		count = 0
		for i in array:
			if i == x:
				count += 1
		return count > len(array)/2


——————————————————————————————————————————————————————————————————————————————————————————————————
【连续子数组的最大和】
今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。
但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？
例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。
给一个数组，返回它的最大连续子序列的和？(子向量的长度至少是1)
class Solution:
	def FindGreatestSumOfSubArray(self, array):
		res = float('-inf')
		dp = [0] * len(array)
		dp[0] = array[0]
		for i in range(1,len(array)):
			if dp[i-1] <= 0:
				dp[i] = array[i]
			else:
				dp[i] = dp[i-1] + array[i]
			res = max(res, dp[i])
		return res


——————————————————————————————————————————————————————————————————————————————————————————————————
【和为S的两个数字】
输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
class Solution:
	def FindNumbersWithSum(self, array, tsum):
		i, j = 0, len(array)-1
		while i<j:
			nsum = array[i] + array[j]
			if nsum == tsum:
				return [array[i], array[j]]
			elif nsum > tsum:
				j -= 1
			else:
				i += 1
		return []


——————————————————————————————————————————————————————————————————————————————————————————————————
【和为S的连续正数序列】
小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。
但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。
没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。
现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? 
class Solution:
	def FindContinuousSequence(self, tsum):
		if tsum <= 2:
			return []
		small, big = 1, 2
		nsum = small + big
		res = []
		while small <= tsum/2:
			if nsum == tsum:
				res.append(range(small,big+1))
				nsum -= small                        #注意先更新nsum
				small += 1
			elif nsum > tsum:
				nsum -= small
				small += 1
			else:
				big += 1
				nsum += big
		return res
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
