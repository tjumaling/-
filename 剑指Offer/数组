——————————————————————————————————————————————————————————————————————————————————————————————————
【二维数组的查找】
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
class Solution:
    def Find(self, target, array):
    	m, n = len(array), len(array[0])
	i, j = 0, n-1
	while i < m and j >= 0:
		if array[i][j] == target:
			return True
		elif array[i][j] > target:
			j -= 1
		else:
			i += 1
	return False


——————————————————————————————————————————————————————————————————————————————————————————————————
【旋转数组的最小数字】*******************************
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 
输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
class Solution:
	def minNumberInRotateArray(self, rotateArray):
		m = len(rotateArray)
		if m == 0:
			return 0
		l, r = 0, m-1
		while l < r:
			mid = (r + l) >> 1
			if rotateArray[mid] > rotateArray[r]:
				l = mid + 1
			elif rotateArray[mid] == rotateArray[r]:
				r = r - 1
			else:
				r = mid
		return rotateArray[l]


——————————————————————————————————————————————————————————————————————————————————————————————————
【最小的K个数】
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
class Solution:
	def GetLeastNumbers_Solution(self, tinput, k):
		if len(tinput) == 0 or k > len(tinput) or k<=0:
			return []
		l, r = 0, len(tinput) - 1
		index = self.Partition(tinput, l, r)
		while index != k - 1:
			if index > k-1:
 				r = index - 1
				index = self.Partition(tinput, l, r)
			else:
				l = index + 1
				index = self.Partition(tinput, l, r)
		return sorted(tinput[:k])
	def Partition(self,numbers,l,r):
		x = numbers[r]
		i = l - 1
		for j in range(l,r):
    			if numbers[j] <= x:
				i += 1
				numbers[i], numbers[j] = numbers[j], numbers[i]
		numbers[i+1], numbers[r] = numbers[r], numbers[i+1]
		return i+1


——————————————————————————————————————————————————————————————————————————————————————————————————
【连续子数组的最大和】
今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。
但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？
例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。
给一个数组，返回它的最大连续子序列的和？(子向量的长度至少是1)
class Solution:
	def FindGreatestSumOfSubArray(self, array):
		res = float('-inf')
		dp = [0] * len(array)
		dp[0] = array[0]
		for i in range(1,len(array)):
			if dp[i-1] <= 0:
				dp[i] = array[i]
			else:
				dp[i] = dp[i-1] + array[i]
			res = max(res, dp[i])
		return res












