___________________________________________________________________________________________________
【重建二叉树】
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
class Solution:
	def reConstructBinaryTree(self, pre, tin):
		if not pre:
			return None
		node = ListNode(pre[0])
		index = tin.index(pre[0])
		node.left = self.reConstructBinaryTree(pre[1:index+1],tin[:index])
		node.right = self.reConstructBinaryTree(pre[index+1:],tin[index+1:])
		return node


___________________________________________________________________________________________________
【平衡二叉树】
输入一棵二叉树，判断该二叉树是否是平衡二叉树。
class Solution:
	#一般循环，无剪枝
	def IsBalanced_Solution(self, pRoot):
		if pRoot == None:
			return True
		return abs(self.depth(pRoot.left)-self.depth(pRoot.right))<=1 and self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)
	def depth(self, pRoot):
		if pRoot == None:
			return 0
		return max(self.depth(pRoot.left),self.depth(pRoot.right)) + 1
	#优化，加剪枝
	def IsBalanced_Solution(self, pRoot):
		return self.helper(pRoot) != -1
	def helper(self, pRoot):
		if pRoot == None:
			return 0
		left = self.helper(pRoot.left)
		if left == -1:
			return -1
		right = self.helper(pRoot.right)
		if right == -1:
			return -1
		return -1 if abs(left-right)>1 else 1 + max(left,right)


___________________________________________________________________________________________________
【从上往下打印二叉树】
class Solution:
	def PrintFromTopToBottom(self, root):
		if root == None:
			return []
		stack = [root]
		res = []
		while stack:
			node = stack.pop(0)
			res.append(node.val)
			if node.left:
				stack.append(node.left)
			if node.right:
				stack.append(node.right)
		return res
	

___________________________________________________________________________________________________
【二叉树的镜像】
操作给定的二叉树，将其变换为源二叉树的镜像。
class Solution:
	def Mirror(self, root):
		if root == None:
			return root
		qu = [root]
		while qu:
			node = qu.pop(0)
			if node.left == None and node.right == None:
				continue 
			temp = node.left
			node.left = node.right
			node.right = temp
			if node.left:
				qu.append(node.left)
			if node.right:
				qu.append(node.right)
		return root
			
		
___________________________________________________________________________________________________
【二叉树中和为某一值的路径】	
输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
(注意: 在返回值的list中，数组长度大的数组靠前)	

		
		
		
		
		
		
		
		
		
	
