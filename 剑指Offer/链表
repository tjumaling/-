————————————————————————————————————————————————————————————————————————————————————————————————————
【从尾到头打印链表】
输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。
class Solution:
	#不改变原List
	def printListFromTailToHead(self, listNode):
		stack = []
		while listNode:
			stack.append(listNode.val)
			listNode = listNode.next
		res = []
		while stack:
			res.append(stack.pop())
		return res
	#改变原List
	def printListFromTailToHead(self, listNode):
		if listNode and listNode.next:
			pre = None
			now = listNode
			nxt = listNode.next
			while nxt:
				now.next = pre
				pre = now
				now = nxt
				nxt = now.next
			now.next = pre
		else:
			now = listNode
		res = []
		while now:
			res.append(now.val)
			now = now.next
		return res


————————————————————————————————————————————————————————————————————————————————————————————————————
【反转链表】
输入一个链表，反转链表后，输出新链表的表头。
class Solution:
	def ReverseList(self, pHead):
		if pHead == None or pHead.next == None:
			return pHead
		pre = None
		now = pHead
		nxt = pHead.next
		while nxt:
			now.next = pre
			pre = now
			now = nxt
			nxt = now.next
		now.next = pre
		return now
	

————————————————————————————————————————————————————————————————————————————————————————————————————
【合并两个排序的链表】
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
class Solution:
	def Merge(self, pHead1, pHead2):
		p = ListNode(0)
		res = p
		while pHead1 and pHead2:
			if pHead1.val < pHead2.val:
				p.next = pHead1
				pHead1 = pHead1.next
			else:
				p.next = pHead2
				pHead2 = pHead2.next
			p = p.next
		while pHead1:
			p.next = pHead1
			p = p.next 
			pHead1 = pHead1.next
		while pHead2:
			p.next = pHead2
			p = p.next
			pHead2 = pHead2.next
		return res.next


————————————————————————————————————————————————————————————————————————————————————————————————————
【两个链表的第一个公共结点】
输入两个链表，找出它们的第一个公共结点。
class Solution:
	def FindFirstCommonNode(self, pHead1, pHead2):
		m = self.getLen(pHead1)
		n = self.getLen(pHead2)
		if m < n:
			pHead1, pHead2 = pHead2, pHead1
			m, n = n, m
		for i in range(m-n):
			pHead1 = pHead1.next
		while pHead1 and pHead2:
			if pHead1 == pHead2:
				return pHead1
			pHead2 = pHead2.next
			pHead1 = pHead1.next
	def getLen(self, p):
		m = 0
		while p:
			m += 1
			p = p.next
		return m
		
		
————————————————————————————————————————————————————————————————————————————————————————————————————	
【复杂链表的复制】
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。
（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
class Solution:
	def Clone(self, pHead):
		if pHead == None:
			return None
		self.cloneNode(pHead)
		self.connectRandom(pHead)
		return self.reconnect(pHead)
	def cloneNode(self, pHead):
		while pHead:
			node = RandomListNode(pHead.label)
			node.next = pHead.next
			pHead.next = node
			pHead = node.next
	def connectRandom(self, pHead):
		while pHead:
			if pHead.random:
				pHead.next.random = pHead.random.next
			pHead = pHead.next.next
	def reconnect(self, pHead):
		q = pHead
		res = p = pHead.next
		while p and q:
			q.next = p.next
			q = q.next
			if q:
				p.next = q.next
				p = p.next
		return res



