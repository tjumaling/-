_____________________________________________________________________________________________________
【冒泡排序】
def bubbleSort(Array):
	m = len(Array)
	if m <= 1:
		return Array
	for i in range(m-1):
		for j in range(m-1-i):
			if Array[j] > Array[j+1]:
				Array[j], Array[j+1] = Array[j+1], Array[j]
	return Array


_____________________________________________________________________________________________________
【快排】
#递归
def quickSort(Array, l, r):
	if l < r:
		q = partition(Array, l, r)
		quickSort(Array, l, q-1)
		quickSort(Array, q+1, r)
def partition(Array, l, r):
	x = Array[r]
	i = l-1
	for j in range(l, r):
		if Array[j] <= x:
			i += 1
			Array[i], Array[j] = Array[j], Array[i]
	Array[i+1], Array[r] = Array[r], Array[i+1]
	return i+1
	
#非递归
def quickSort(Array):
	l, r = 0, len(Array)-1
	stack = [l, r]
	while stack:
		left = stack.pop(0)
		right = stack.pop(0)
		x = Array[right]
		i = left - 1
		for j in range(left, right):
			if Array[j] <= x:
				i += 1
				Array[j], Array[i] = Array[i], Array[j]
		Array[i+1], Array[right] = Array[right], Array[i+1]
		if left < i:
			stack.extend([left, i])
		if i+2 < right:
			stack.extend([i+2, right])
		
		
_____________________________________________________________________________________________________
【归并排序】
def mergeSort(Array):
	if len(Array) == 1:
		return Array
	middle = len(Array)//2
	left = mergeSort(Array[:middle])
	right = mergeSort(Array[middle:])
	return merge(left, right)
def merge(A, B):
	C = []
	i = j = 0
	while i < len(A) and j < len(B):
		if A[i] > B[j]:
			C.append(B[j])
			j += 1
		else:
			C.append(A[i])
			i += 1
	while i < len(A):
		C.append(A[i])
		i += 1
	while j < len(B):
		C.append(B[j])
		j += 1
	return C


_____________________________________________________________________________________________________
【二叉树前中后遍历的递归版本】
#前序遍历
def preOrder(pHead):
	if pHead:
		print(pHead.val)
		preOrder(pHead.left)
		preOrder(pHead.right)
#中序遍历	
def inOrder(pHead):
	if pHead:
		inOrder(pHead.left)
		print(pHead.val)
		inOrder(pHead.right)
#后序遍历
def postOrder(pHead):
	if pHead:
		postOrder(pHead.left)
		postOrder(pHead.right)
		print(pHead.val)		

_____________________________________________________________________________________________________
【二叉树前中后遍历的非递归版本】
#前序遍历
def preOrder(pHead):
	stack = []
	p = pHead
	res = []
	while p or stack:
		while p != None:
			res.append(p.val)
			stack.append(p)
			p = p.left
		if stack != []:
			p = stack.pop()
			p = p.right
	return res
#中序遍历	
def inOrder(pHead):
	stack = []
	res = []
	p = pHead
	while p or stack:
		while p != None:
			stack.append(p)
			p = p.left
		if stack != []:
			p = stack.pop()
			res.append(p.val)
			p = p.right
	return res
#后序遍历
def postOrder(pHead):


































